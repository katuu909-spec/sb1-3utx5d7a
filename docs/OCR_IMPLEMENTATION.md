# OCR 実装ガイド（安全・精度重視）

## 方針
- 画像はフロントで最小化（不要部分マスク/クロップ、リサイズ・圧縮）してから送信。
- API キーはサーバー/サーバーレス関数の環境変数で保持し、フロントには出さない。
- クラウドOCRはリージョン指定・学習オプトアウトを確認（例: Google Vision / AWS Textract）。
- ストレージを使う場合は短命プリサインドURL、処理後は削除（可能なら保存せず直接送信）。
- ログには画像や識別情報を残さない。結果は信頼度付きで返し、低信頼なら手修正を促す。

## 推奨ワークフロー
1. **クラウドOCRの選定**
   - 例: Google Vision (TEXT_DETECTION)、AWS Textract。リージョンとデータ保持/学習利用ポリシーを確認。
2. **サーバーレス関数を追加（例: `api/ocr.ts`）**
   - 入力: クロップ済み/圧縮済み画像（base64 or バイナリ）。
   - 処理: OCR呼び出し → 数値フィルタ → 信頼度付きで返却。
   - APIキーは環境変数。レスポンスとログに画像は残さない。
3. **フロントの前処理**
   - 撮影→グレースケール→二値化/コントラスト調整→必要箇所のみクロップ→リサイズ（短辺≥1000px程度）→JPEG圧縮。
   - 可能ならガイド枠/傾き警告/再撮影ボタンを表示。
4. **結果表示と手修正**
   - OCR結果と元画像を並べて確認入力欄にセット。
   - 信頼度が低い場合は自動反映せず、再撮影/手入力を促す。
   - 数値フィルタ、桁・範囲バリデーション、外れ値検出。
5. **ストレージ運用（必要な場合）**
   - プリサインドURLを短期発行（数分〜数十分）。処理後に削除。
   - 可能ならストレージを経由せず直接APIに送信。
   - 即時OCRと保存を分離する場合:
     - `/api/ocr`: 画像を受けてOCRのみ実行（保存しない）。
     - `/api/upload`: Supabase Storage に保存（プリサインドURL or service key）。
     - フロー例: ① `/api/ocr` で認識 → OKなら ② `/api/upload` で保存。
6. **エラーハンドリング**
   - OCR失敗時に明示メッセージ＋手入力/再撮影導線。
   - レートリミット・コスト制御（サーバー側でメータリング）。

## セキュリティ上の注意
- 機密情報が写る場合は送信前にマスク/トリミング。
- HTTPS 経由で送信。バックエンドの CORS/認証を有効化。
- ログにはサニタイズ済みメタデータのみを残し、画像データを残さない。
- リージョンをデータ規制に合わせて選択。保持ポリシーと学習利用を確認。

## 実装時の最小チェックリスト
- [ ] APIキーをフロントに置かない（サーバー/関数で管理）。
- [ ] 画像を前処理し最小化（クロップ/圧縮）して送信。
- [ ] レスポンスに信頼度を含め、低信頼時は自動入力しない。
- [ ] 数値フィルタ＋範囲/桁バリデーションをかける。
- [ ] ストレージ利用時は短命URL＋処理後削除、または無保存で直接OCR。
- [ ] ログに画像や識別情報を残さない。

